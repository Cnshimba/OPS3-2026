<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transition to Cloud Computing Concepts - Presentation Slides</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            page-break-after: always;
            border-bottom: 3px solid #0f3460;
        }
        
        .slide:nth-child(even) {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        }
        
        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .title-slide .week-number {
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .title-slide .course-code {
            font-size: 1.2em;
            color: #a8dadc;
            margin-top: 30px;
        }
        
        h2 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 30px;
            border-bottom: 3px solid #ffd700;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 25px;
        }
        
        ul {
            font-size: 1.4em;
            margin-left: 40px;
            margin-bottom: 20px;
        }
        
        ul li {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        p {
            font-size: 1.3em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .code-block {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', monospace;
            color: #a8dadc;
        }
        
        .quote {
            background: rgba(233, 69, 96, 0.1);
            border-left: 5px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.2em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        th {
            background: #0f3460;
            color: #ffd700;
            padding: 15px;
            text-align: left;
            border: 1px solid #16213e;
        }
        
        td {
            padding: 12px;
            border: 1px solid #16213e;
            background: rgba(255, 255, 255, 0.05);
        }
        
        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .key-points {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .slide-number {
            position: fixed;
            bottom: 20px;
            right: 30px;
            font-size: 1em;
            color: #a8dadc;
            opacity: 0.7;
        }
        
        @media print {
            .slide {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>

    <div class="slide title-slide">
        <div class="week-number">Week 7</div>
        <h1>Transition to Cloud Computing Concepts</h1>
        <div class="course-code">OPS3 - Virtualization and Cloud Infrastructure</div>
        <div class="slide-number">Slide 1</div>
    </div>

    <div class="slide">
        <h2>Welcome to Week 7!</h2>
        <div class="slide-number">Slide 2</div>
    </div>

    <div class="slide">
        <h2>Core Comparison: Proxmox vs. OpenStack</h2>
        <div class="slide-number">Slide 3</div>
    </div>

    <div class="slide">
        <h3>1. The Fundamental Difference</h3>
        <ul>
            <li>Proxmox VE is built for the "Pet" philosophy.</li>
            <li>In this model, each server is unique, important, and manually cared for.</li>
            <li>If a "Pet" server gets sick (fails), the administrator rushes to nurse it back to health.</li>
            <li>This approach implies vertical scaling (making the VM bigger) and is ideal for workloads that require manual fine-tuning and persistence.</li>
        </ul>
        <ul>
            <li>OpenStack, in contrast, is built for the "Cattle" philosophy.</li>
            <li>In this model, servers are disposable resources mass-produced in a factory.</li>
            <li>They are given numbers, not names.</li>
            <li>If a "Cattle" server gets sick, it is replaced, not fixed.</li>
            <li>This approach relies on horizontal scaling (adding more VMs) and is designed for developers who consume infrastructure via APIs.</li>
        </ul>
        <div class="slide-number">Slide 4</div>
    </div>

    <div class="slide">
        <h3>2. Enterprise Deployment Scenarios</h3>
        <ul>
            <li>Proxmox in the Enterprise is typically found in Small-to-Medium Enterprises (SMEs) or specific branch offices.</li>
            <li>It excels at hosting "static" workloads that do not change often, such as File Servers, Print Servers, Legacy ERP systems, and Domain Controllers.</li>
            <li>IT Managers choose Proxmox because it is lightweight, easy to maintain, and requires less hardware overhead than a full cloud stack.</li>
        </ul>
        <ul>
            <li>OpenStack in the Enterprise is the domain of Large Enterprises, Telecommunications providers, and Research Institutes.</li>
            <li>It is designed for "dynamic" workloads where infrastructure needs to scale up and down automatically to match demand, such as web applications, CI/CD build pipelines, and big data clusters.</li>
            <li>Organizations choose OpenStack when they need to provide an "AWS-like" self-service experience to their internal teams while strictly maintaining Data Sovereignty within their own private data centers.</li>
        </ul>
        <div class="slide-number">Slide 5</div>
    </div>

    <div class="slide">
        <h2>1. Defining "The Cloud" (NIST Model)</h2>
        <div class="slide-number">Slide 6</div>
    </div>

    <div class="slide">
        <h3>1.1 Service Models (The Pizza Analogy)</h3>
        <p>Cloud computing is delivered via three primary models, best understood through the famous "Pizza as a Service" analogy which compares managing infrastructure to eating dinner.</p>
        <p>Figure 2: NIST Cloud Service Models - The progression from managing everything (On-Prem) to managing nothing (SaaS)</p>
        <p>On-Premise (Homemade Pizza) represents traditional IT. You own the kitchen, buy the ingredients, cook the pizza, and clean the table. You are responsible for managing every layer of the stack, from networking cables to the application code.</p>
        <ul>
            <li>Infrastructure as a Service - IaaS (Take & Bake Pizza) gives you the "Kitchen" but you bring the "Pizza." The provider manages the physical hardware (Networking, Storage, Servers, Virtualization).</li>
            <li>You rent the Virtual Machine and are responsible for installing the Operating System, patching it, and running your application.</li>
            <li>This is the model OpenStack provides.</li>
        </ul>
        <ul>
            <li>Platform as a Service - PaaS (Pizza Delivery) handles almost everything.</li>
            <li>The provider manages the hardware and the Operating System runtime.</li>
            <li>You simply provide the code (the "Order") and they deliver the running application.</li>
            <li>You don't worry about Windows updates or Linux kernels; you focus solely on development.</li>
        </ul>
        <p>Software as a Service - SaaS (Dining Out) is the ultimate abstraction. You simply go to the restaurant and eat. The provider manages everything from the hardware to the application software itself. You just log in and use the tool (e.g., Gmail, Salesforce).</p>
        <div class="slide-number">Slide 7</div>
    </div>

    <div class="slide">
        <h3>1.2 Service Models Expanded</h3>
        <p>While the Pizza analogy serves as an excellent high-level overview, engineering teams require a more granular understanding of responsibilities in the cloud.</p>
        <ul>
            <li>Infrastructure as a Service (IaaS) represents the foundational layer of cloud computing.</li>
            <li>In this model, the cloud provider supplies the raw compute power, storage, and networking hardware, effectively serving as a virtual data center.</li>
            <li>As a consumer, you retain the highest level of control but also bear the greatest responsibility.</li>
            <li>You are tasked with installing the operating system, patching the kernel, configuring firewalls, and managing all middleware and runtime environments.</li>
            <li>It offers the flexibility to run almost any workload but requires significant administrative overhead.</li>
        </ul>
        <ul>
            <li>Platform as a Service (PaaS) abstracts the underlying infrastructure to provide a streamlined environment specifically for developers.</li>
            <li>The provider manages the servers, storage, networking, operating system, and middleware, allowing developers to focus solely on writing and deploying code.</li>
            <li>This model significantly increases convenience and speed of deployment but sacrifices granular control over the environment.</li>
            <li>If your application requires a custom kernel module or specific OS tweak, PaaS may be too restrictive.</li>
            <li>Common examples include Heroku, Google App Engine, and AWS Lambda.</li>
        </ul>
        <ul>
            <li>Software as a Service (SaaS) delivers fully functional applications directly to the end-user over the internet.</li>
            <li>In this model, the consumer has zero visibility or control over the underlying infrastructure or platform.</li>
            <li>The provider manages everything from the hardware to the application code itself, ensuring high availability and security.</li>
            <li>This model creates maximum convenience for users who simply need a tool to perform a task, such as email or document collaboration.</li>
            <li>Examples include Gmail, Salesforce, and Microsoft 365.</li>
        </ul>
        <div class="slide-number">Slide 8</div>
    </div>

    <div class="slide">
        <h3>1.3 Common Cloud Providers</h3>
        <p>The global cloud market is segmented into public hyperscalers and private cloud solutions, each catering to specific enterprise needs.</p>
        <ul>
            <li>Amazon Web Services (AWS) is the pioneer and current market leader in public cloud computing.</li>
            <li>It offers the most extensive catalog of services, numbering over 200 distinct products.</li>
            <li>AWS is often the default choice for startups and enterprises seeking a "one-stop-shop" for everything from simple compute to complex machine learning and satellite ground stations.</li>
            <li>Its maturity and breadth making it a safe, albeit complex, choice for general-purpose cloud computing.</li>
        </ul>
        <ul>
            <li>Microsoft Azure dominates the enterprise sector, particularly among organizations already invested in the Microsoft ecosystem.</li>
            <li>Its primary strength lies in its seamless integration with Windows Server, Active Directory, and Microsoft 365.</li>
            <li>For companies running .NET applications or requiring hybrid cloud setups that extend their on-premise Active Directory to the cloud, Azure offers the path of least resistance.</li>
        </ul>
        <ul>
            <li>Google Cloud Platform (GCP) differentiates itself through engineering excellence in data analytics, artificial intelligence, and container orchestration.</li>
            <li>Having invented Kubernetes, Google makes GCP the premier environment for container-native applications and microservices.</li>
            <li>It is frequently chosen by organizations heavily focused on big data processing and machine learning workflows.</li>
        </ul>
        <ul>
            <li>OpenStack stands apart as the de facto standard for Private Cloud infrastructure.</li>
            <li>Unlike the hyperscalers where you rent space on someone else's computer, OpenStack allows you to build the cloud in your own data center.</li>
            <li>This is the preferred choice for telecommunications providers, governments, and research institutes (like CERN) who require absolute control over their data sovereignty, or who operate at such a massive scale that renting public cloud resources becomes cost-prohibitive.</li>
        </ul>
        <div class="slide-number">Slide 9</div>
    </div>

    <div class="slide">
        <h3>1.4 Cloud Deployment Models</h3>
        <p>Understanding the "Where" and "Who" of cloud computing is defined by three primary deployment models.</p>
        <p>Figure 3: Cloud Deployment Models - Public (Shared), Private (Dedicated), and Hybrid (Bridged)</p>
        <ul>
            <li>Public Cloud is the most common model, where resources are owned and operated by a third-party provider (like AWS or Azure) and shared across millions of customers via the public internet.</li>
            <li>It offers the highest level of efficiency and elasticity but requires trusting the provider with your data and accepting a multi-tenant environment where your "neighbor" could be anyone.</li>
            <li>It is ideal for startups, web hosting, and highly variable workloads that need to scale instantly.</li>
        </ul>
        <ul>
            <li>Private Cloud is infrastructure provisioned for the exclusive use of a single organization.</li>
            <li>It can be hosted on-premise (in your own building) or by a third-party, but the hardware is strictly dedicated and never shared with other customers.</li>
            <li>This model offers maximum control, security, and performance customization, making it the non-negotiable choice for banks, governments, and regulated industries.</li>
            <li>OpenStack is the global standard for building these Private Clouds.</li>
        </ul>
        <ul>
            <li>Hybrid Cloud represents the best of both worlds, combining Public and Private clouds bound together by technology that allows data and applications to be shared between them.</li>
            <li>A typical enterprise use case involves keeping sensitive customer databases "on-premise" in a Private Cloud for strict security compliance, while running web-server frontends in a Public Cloud to take advantage of infinite scaling during traffic spikes (a technique known as Cloud Bursting).</li>
        </ul>
        <div class="slide-number">Slide 10</div>
    </div>

    <div class="slide">
        <h3>1.5 Cloud Structure: Regions and Zones</h3>
        <p>The cloud is not a nebulous entity floating in the sky; it is composed of massive physical data centers connected by high-speed fiber optics. Understanding its physical geography is essential for designing resilient applications.</p>
        <p>Figure 4: Regions vs Availability Zones - A Region contains multiple isolated AZs to prevent a single disaster from taking down the entire service</p>
        <ul>
            <li>A Region is a specific geographical location (e.g., "US-East", "Europe-West", "Africa-South") that contains a cluster of data centers.</li>
            <li>Each region is completely independent; if the US-East region loses power or suffers a natural disaster, the Europe-West region remains unaffected.</li>
            <li>Data compliance laws (such as GDPR or POPI) often dictate exactly which Region you must store your user data in to remain within legal jurisdictions.</li>
        </ul>
        <ul>
            <li>An Availability Zone (AZ) is an isolated location within a Region.</li>
            <li>Think of an AZ as a separate physical building (or cluster of buildings) with its own independent power grids, cooling systems, and networking infrastructure.</li>
            <li>A Region is typically made up of multiple AZs (usually 3 or more).</li>
            <li>To achieve High Availability, cloud architects deploy applications across multiple AZs.</li>
            <li>If "Building A" burns down, "Building B" continues to run the application without interruption.</li>
        </ul>
        <div class="slide-number">Slide 11</div>
    </div>

    <div class="slide">
        <h3>1.6 The Four Pillars of Cloud Infrastructure</h3>
        <p>Regardless of whether you use AWS, Azure, or OpenStack, all cloud platforms are built on four fundamental pillars.</p>
        <p>Compute represents the processing power (CPU and RAM). In the cloud, this manifests as ephemeral Virtual Machines (Instances) or Containers. These resources are designed to be launched, used, and destroyed on demand. We treat them as disposable workers rather than permanent fixtures.</p>
        <p>Networking is the nervous system of the cloud. It involves creating Virtual Private Clouds (VPCs), subnets, and defining how traffic flows between them. In a software-defined cloud, we program routers, load balancers, and floating IPs using APIs rather than plugging in physical cables.</p>
        <p>Storage is divided into two primary types: Block Storage (like a virtual hard drive attached to a VM) for operating systems and databases, and Object Storage (like a massive, limitless bucket) for storing unstructured files like photos, videos, and backups.</p>
        <ul>
            <li>Security in the cloud shifts from physical perimeter defense (locks and guards) to identity-based and software-defined security.</li>
            <li>Security Groups act as virtual distributed firewalls applied directly to each instance, controlling inbound and outbound traffic at the packet level regardless of network topology.</li>
            <li>Identity and Access Management (IAM) acts as the central directory, strictly controlling who (users/services) can perform what actions (permissions) on which specific resources.</li>
        </ul>
        <div class="slide-number">Slide 12</div>
    </div>

    <div class="slide">
        <h3>1.7 The Shared Responsibility Model</h3>
        <p>Moving to the cloud does not absolve you of security responsibilities; it simply changes what you are responsible for. The Shared Responsibility Model is a framework that defines the security obligations of both the Cloud Provider and the Customer.</p>
        <ul>
            <li>In an On-Premise environment, you are responsible for everything from the physical door lock to the user's password.</li>
            <li>In an IaaS model (like OpenStack), the Provider secures the physical data center, network hardware, and hypervisor.</li>
            <li>You, the Customer, are responsible for securing the Guest OS, applications, data, and firewall configurations.</li>
            <li>As you move up the stack to PaaS and SaaS, the Provider takes on more responsibility (like patching the OS), but you are always responsible for your Data and Identity (User Accounts).</li>
        </ul>
        <div class="slide-number">Slide 13</div>
    </div>

    <div class="slide">
        <h3>1.8 Cloud Economics: CapEx vs. OpEx</h3>
        <p>One of the primary drivers for cloud adoption is financial, specifically the shift in how IT is funded.</p>
        <ul>
            <li>Capital Expenditure (CapEx) is the traditional model where you spend a large amount of money upfront to buy physical servers, storage arrays, and network switches.</li>
            <li>This is an "Investment" that depreciates over 3-5 years.</li>
            <li>You pay for the maximum capacity you might need, which often leads to underutilization.</li>
        </ul>
        <ul>
            <li>Operational Expenditure (OpEx) is the cloud model where you pay for services as you use them (Pay-as-you-Go).</li>
            <li>There is no upfront cost.</li>
            <li>This aligns spending with actual usage.</li>
            <li>If you shut down your VMs at night, you stop paying.</li>
            <li>This shifts IT spending from a "Fixed Cost" to a "Variable Cost," allowing businesses to be more agile.</li>
        </ul>
        <div class="slide-number">Slide 14</div>
    </div>

    <div class="slide">
        <h3>1.9 Scalability vs. Elasticity</h3>
        <p>While often used interchangeably by marketing teams, these two terms describe fundamentally different capabilities of a cloud architecture.</p>
        <ul>
            <li>Scalability is the strategic ability of a system to handle projected growth over time.</li>
            <li>A scalable system typically involves human intervention to upgrade capacity.</li>
            <li>This can be achieved through Vertical Scaling (scaling up by adding more RAM/CPU to a single server) or Horizontal Scaling (scaling out by adding more servers to a cluster).</li>
            <li>It effectively answers the question: "Can we get bigger if the company grows?"</li>
        </ul>
        <ul>
            <li>Elasticity is the tactical ability to scale resources automatically in real-time response to demand, in both directions.</li>
            <li>An elastic system adds servers when traffic spikes (e.g., during a Black Friday sale) and removes them when traffic drops (at 3 AM), maintaining performance while optimizing cost.</li>
            <li>It answers the question: "Can the system resize itself right now without human help?"</li>
        </ul>
        <div class="slide-number">Slide 15</div>
    </div>

    <div class="slide">
        <h3>1.10 Migration Strategies (The 6 Rs)</h3>
        <p>Transitioning to the cloud is not a simple "copy and paste" operation; it requires a strategic decision for each application in your portfolio. The industry-standard framework, popularized by Amazon Web Services (AWS) and Gartner, defines the "6 Rs" of migration.</p>
        <ul>
            <li>1.</li>
            <li>Rehost ("Lift and Shift")
This is the fastest and lowest-risk strategy.</li>
            <li>It involves moving an application from on-premise to the cloud without making any changes to its underlying architecture.</li>
            <li>For example, exporting a virtual machine from VMware and importing it directly into OpenStack.</li>
            <li>While quick, this method typically fails to realize the long-term benefits of the cloud, such as auto-scaling and elasticity, because the application still thinks it is running on a static server.</li>
        </ul>
        <ul>
            <li>2.</li>
            <li>Replatform ("Lift, Tweak, and Shift")
This strategy involves making small optimizations to the application to run more efficiently in the cloud without rewriting the core code.</li>
            <li>A common example is migrating a local MySQL database to a managed SQL service (PaaS) or containerizing a legacy application to run on Kubernetes.</li>
            <li>This offers a middle ground, providing some cloud benefits without the heavy cost of a full rewrite.</li>
        </ul>
        <ul>
            <li>3.</li>
            <li>Refactor (Re-architect)
Refactoring is the most expensive but most rewarding strategy.</li>
            <li>It involves rewriting the application from scratch to be "Cloud Native." For instance, breaking a monolithic Java application into dozens of Python microservices that communicate via APIs.</li>
            <li>This allows the application to scale infinitely and heal itself, fully unlocking the power of the cloud.</li>
        </ul>
        <ul>
            <li>4.</li>
            <li>Repurchase ("Drop and Shop")
This involves abandoning the legacy application entirely and moving to a commercial SaaS solution.</li>
            <li>A classic example is decommissioning an on-premise Microsoft Exchange Server and migrating all users to Microsoft 365.</li>
            <li>Further examples include moving logical CRM systems to Salesforce.</li>
        </ul>
        <p>5. Retire
Upon analysis, many organizations discover applications that are no longer useful. These are simply turned off, resulting in immediate cost savings.</p>
        <p>6. Retain
Some applications are simply too complex, too sensitive, or too intertwined with legacy hardware (like mainframes) to serve as viable candidates for migration. These are deliberately kept on-premise.</p>
        <div class="slide-number">Slide 16</div>
    </div>

    <div class="slide">
        <h3>Section 1 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>NIST Cloud Definition: Self-Service, Broad Access, Pooling, Elasticity, Measured.</li>
            <li>Service Models: IaaS (Rent Hardware), PaaS (Rent Platform), SaaS (Rent App).</li>
            <li>Deployment: Public (Shared), Private (Dedicated), Hybrid (Mixed).</li>
            <li>Shared Responsibility: You are always responsible for Data and Identity.</li>
            <li>Economics: Shift from CapEx (Investment) to OpEx (Consumption).</li>
            <li>Dynamics: Scalability (Growth) vs Elasticity (Auto-sizing).</li>
            <li>Migration: Rehost (Fastest) vs Refactor (Best Long-term).</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>In a SaaS model (like Gmail), who is responsible if you share a confidential file with the wrong person? (Hint: Shared Responsibility).</li>
            <li>Why does the CFO (Chief Financial Officer) prefer OpEx over CapEx for a risky new startup?</li>
            <li>Can a system be Scalable but not Elastic? Give an example.</li>
            <li>Which migration strategy would you use for a 20-year-old Legacy ERP system that nobody knows how to modify? (Hint: Lift and Shift).</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>NIST Cloud Computing Definition (PDF)</li>
            <li>Book: CompTIA Cloud+ Certification Study Guide (Exam CV0-003) - Ben Piper.</li>
            <li>Whitepaper: AWS "6 Strategies for Migrating Applications"</li>
        </ul>
        <div class="slide-number">Slide 17</div>
    </div>

    <div class="slide">
        <h2>2. Introducing OpenStack</h2>
        <div class="slide-number">Slide 18</div>
    </div>

    <div class="slide">
        <h3>2.1 The "Core" Services (Remember these Names!)</h3>
        <ul>
            <li>OpenStack can be overwhelming because it consists of dozens of projects.</li>
            <li>However, a functional cloud only requires a handful of core services to operate.</li>
            <li>These "Big 5" services form the foundation of almost every deployment, handling computation, networking, identity, storage images, and the user interface.</li>
        </ul>
        <p>Figure 6: OpenStack Core Services Map - Highlighting the interaction between Nova, Neutron, Glance, Keystone, and Horizon</p>
        <ul>
            <li>Nova is the heart of OpenStack.</li>
            <li>It is responsible for the entire lifecycle of a Virtual Machine (Instance), from spawning to termination.</li>
            <li>It is not a single binary but a distributed system.</li>
            <li>The nova-api accepts requests, the nova-scheduler uses complex filters (like RamFilter) to decide which physical server is best suited for the VM, and nova-compute talks to the underlying hypervisor (KVM) to actually run the process.</li>
        </ul>
        <ul>
            <li>Neutron is the "Plumber" of the cloud.</li>
            <li>It manages "Software Defined Networking" (SDN).</li>
            <li>It uses the ML2 Plugin (Modular Layer 2) to talk to different backend technologies, such as Open vSwitch or Linux Bridge.</li>
            <li>It employs an L3 Agent to handle virtual routing and floating IPs, and a DHCP Agent to automatically assign IP addresses to instances via dnsmasq.</li>
        </ul>
        <ul>
            <li>Keystone is the "Bouncer." It provides a single point of integration for securing the cloud.</li>
            <li>It maintains the Service Catalog (a registry of where all other APIs live) and issues Fernet Tokens—lightweight, encrypted keys—that users and services present to authenticate themselves for every single action.</li>
        </ul>
        <ul>
            <li>Glance is the "Librarian." It stores and retrieves virtual machine disk images.</li>
            <li>When you want to launch an "Ubuntu 22.04" server, Nova asks Glance to provide the image file.</li>
            <li>Glance can store these images on a local hard drive, or more commonly, in an enterprise Object Storage system like Ceph, ensuring that your "golden master" images remain immutable and secure.</li>
        </ul>
        <ul>
            <li>Horizon is the "Face" of OpenStack.</li>
            <li>It provides a web-based graphical user interface (GUI) that allows users to launch instances, configure networks, and managed storage without typing a single command.</li>
            <li>Under the hood, Horizon is simply a Python Django web application that translates user clicks into API calls sent to Nova, Neutron, and Keystone.</li>
        </ul>
        <div class="slide-number">Slide 19</div>
    </div>

    <div class="slide">
        <h3>2.2 How they work together: A Day in the Life of a Request</h3>
        <p>To understand cloud architecture, let's trace exactly what happens when a user clicks "Launch Instance". It is a coordinated dance between the services.</p>
        <p>Figure 7: The 5-Step VM Provisioning Workflow - A coordinated sequence of API calls ensuring authentication, scheduling, networking, and storage provisioning</p>
        <ul>
            <li>Step 1: Authorization (Keystone)
The user's request first goes to Keystone.</li>
            <li>It validates the user's Token and checks the Policy engine to ensure they have the specific permission (compute:create) required to launch an instance.</li>
            <li>If the token is expired or the user lacks the "Member" role, the request is rejected immediately with a 403 Forbidden error, protecting the cloud resources from unauthorized access.</li>
        </ul>
        <ul>
            <li>Step 2: Scheduling (Nova)
Once authorized, the request is passed to nova-api.</li>
            <li>It asks the nova-scheduler: "Where should I put this VM?" The Scheduler analyzes the state of all available compute nodes using filters.</li>
            <li>Data centers are heterogeneous, so the scheduler checks constraints: "Does this node have 4GB RAM free?" (RamFilter) and "Is this node currently alive?" (ComputeFilter).</li>
            <li>It then selects the mathematically optimal candidate (e.g., Compute-Node-05).</li>
        </ul>
        <ul>
            <li>Step 3: Network Provisioning (Neutron)
Before starting the VM, Nova acts as a proxy and contacts Neutron.</li>
            <li>It requests a port on the specified network (e.g., private-net).</li>
            <li>Neutron creates a logical port entry in its database, assigns a MAC address (e.g., fa:16:3e...), and allocates an IP address (e.g., 192.168.1.15) via its IPAM driver.</li>
            <li>Crucially, it creates this logical reservation before any hardware is touched.</li>
        </ul>
        <ul>
            <li>Step 4: Image Retrieval (Glance)
The nova-compute service on the selected node (Compute-Node-05) receives the command to build.</li>
            <li>It checks its local image cache for the requested OS image (e.g., Ubuntu 22.04).</li>
            <li>If the image is missing, it contacts Glance to download it securely via an HTTP API.</li>
            <li>It then converts the image into a bootable volume, typically using a Copy-on-Write (CoW) backing file to save space and time.</li>
        </ul>
        <ul>
            <li>Step 5: Wiring (The Final Assembly)
Finally, nova-compute instructs the Hypervisor (KVM/Libvirt) to define the VM.</li>
            <li>Simultaneously, the Neutron L2 Agent on that node detects the new port data and programs the local virtual switch (Open vSwitch) to connect the VM's virtual network card to the physical network bridge.</li>
            <li>Only then does the VM start booting, drawing its IP address from the DHCP agent as it initializes.</li>
        </ul>
        <div class="slide-number">Slide 20</div>
    </div>

    <div class="slide">
        <h3>Section 2 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Nova: Compute (The Brain).</li>
            <li>Neutron: Networking (The Plumber).</li>
            <li>Keystone: Identity/Auth (The Bouncer).</li>
            <li>Glance: Image Storage (The Librarian).</li>
            <li>Horizon: Dashboard GUI (The Face).</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>If Keystone goes down, can you still log in to Horizon?</li>
            <li>Why does Nova need to talk to Glance before starting a VM?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>OpenStack Components Map</li>
        </ul>
        <div class="slide-number">Slide 21</div>
    </div>

    <div class="slide">
        <h2>3. Additional Resources</h2>
        <div class="slide-number">Slide 22</div>
    </div>

    <div class="slide">
        <h2>6. Lab Exercises</h2>
        <div class="slide-number">Slide 23</div>
    </div>

    <div class="slide title-slide">
        <h2>Summary</h2>
        <p style="font-size: 1.5em; margin-top: 30px;">Review the key concepts covered in this week's material</p>
        <p style="font-size: 1.2em; margin-top: 20px; color: #ffd700;">Questions?</p>
        <div class="slide-number">Slide 24</div>
    </div>

</body>
</html>