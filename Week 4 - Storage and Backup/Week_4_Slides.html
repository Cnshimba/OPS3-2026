<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Storage and Backup - Presentation Slides</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            page-break-after: always;
            border-bottom: 3px solid #0f3460;
        }
        
        .slide:nth-child(even) {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        }
        
        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .title-slide .week-number {
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .title-slide .course-code {
            font-size: 1.2em;
            color: #a8dadc;
            margin-top: 30px;
        }
        
        h2 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 30px;
            border-bottom: 3px solid #ffd700;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 25px;
        }
        
        ul {
            font-size: 1.4em;
            margin-left: 40px;
            margin-bottom: 20px;
        }
        
        ul li {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        p {
            font-size: 1.3em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .code-block {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', monospace;
            color: #a8dadc;
        }
        
        .quote {
            background: rgba(233, 69, 96, 0.1);
            border-left: 5px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.2em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        th {
            background: #0f3460;
            color: #ffd700;
            padding: 15px;
            text-align: left;
            border: 1px solid #16213e;
        }
        
        td {
            padding: 12px;
            border: 1px solid #16213e;
            background: rgba(255, 255, 255, 0.05);
        }
        
        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .key-points {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .slide-number {
            position: fixed;
            bottom: 20px;
            right: 30px;
            font-size: 1em;
            color: #a8dadc;
            opacity: 0.7;
        }
        
        @media print {
            .slide {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>

    <div class="slide title-slide">
        <div class="week-number">Week 4</div>
        <h1>Storage and Backup</h1>
        <div class="course-code">OPS3 - Virtualization and Cloud Infrastructure</div>
        <div class="slide-number">Slide 1</div>
    </div>

    <div class="slide">
        <h2>Welcome to Week 4!</h2>
        <div class="slide-number">Slide 2</div>
    </div>

    <div class="slide">
        <h2>What You'll Learn This Week</h2>
        <div class="slide-number">Slide 3</div>
    </div>

    <div class="slide">
        <h2>1. Block Devices and Partitions</h2>
        <div class="slide-number">Slide 4</div>
    </div>

    <div class="slide">
        <h3>1.1 Examining Storage</h3>
        <ul>
            <li>One of the most powerful diagnostic tools in Linux is lsblk (List Block Devices), which provides a visual tree representation of all connected storage devices.</li>
            <li>When you run this command in the terminal, it displays a hierarchical view that shows physical disks, their partitions, and any logical volumes built on top of them.</li>
            <li>This tree structure makes it immediately clear which partitions belong to which disks and how storage is organized across the system.</li>
            <li>For administrators managing Proxmox servers, lsblk is indispensable for quickly understanding storage topology without needing to parse complex configuration files.</li>
            <li>The diagram below illustrates how Linux represents different types of storage devices and their partition schemes:</li>
        </ul>
        <p>Figure 1: Linux Block Devices and Partitions - How the kernel represents different storage types (SATA, NVMe, and their partitions)</p>
        <div class="slide-number">Slide 5</div>
    </div>

    <div class="slide">
        <h3>1.2 Managing Partitions (fdisk)</h3>
        <p>To create a formatted space on a disk, we use fdisk or parted.</p>
        <div class="slide-number">Slide 6</div>
    </div>

    <div class="slide">
        <h3>Section 1 Checkpoint</h3>
        <ul>
            <li>Summary: Linux treats disks as Block Devices (such as /dev/sda), and the lsblk command visualizes the storage hierarchy in a tree format while fdisk is used to create partitions.</li>
            <li>It is important to understand that Proxmox needs the underlying operating system to recognize and manage the disk before it can use it for virtual machine storage.</li>
        </ul>
        <p>Reflection: Consider why NVMe drives have names like nvme0n1 instead of sda. What happens if you attempt to partition a disk that is already mounted and actively in use?</p>
        <p>Resources:</p>
        <ul>
            <li>Arch Wiki: Fdisk</li>
        </ul>
        <div class="slide-number">Slide 7</div>
    </div>

    <div class="slide">
        <h2>2. Logical Volume Manager (LVM)</h2>
        <div class="slide-number">Slide 8</div>
    </div>

    <div class="slide">
        <h3>2.1 The LVM Hierarchy</h3>
        <p>The three-tier architecture of LVM provides the flexibility that traditional partitions lack. As shown in the diagram below, the hierarchy flows from physical disks to virtual volumes:</p>
        <p>Figure 2: LVM Three-Tier Hierarchy - Physical Volumes (PV) combine into Volume Groups (VG), which are divided into Logical Volumes (LV)</p>
        <ul>
            <li>The hierarchy consists of three layers.</li>
            <li>At the foundation is the Physical Volume (PV), which represents the actual disk or partition (for example, /dev/sdb).</li>
            <li>These physical volumes are then combined into a Volume Group (VG), which acts as a unified storage pool—for instance, a data_pool might aggregate multiple drives to provide 500GB of total capacity.</li>
            <li>Finally, Logical Volumes (LV) are carved out from the volume group and allocated for specific uses, such as vm-100-disk for a virtual machine.</li>
        </ul>
        <div class="slide-number">Slide 9</div>
    </div>

    <div class="slide">
        <h3>2.2 Hands-On LVM Commands</h3>
        <p>Proxmox uses LVM extensively. Here is how you manage it manually.</p>
        <div class="slide-number">Slide 10</div>
    </div>

    <div class="slide">
        <h3>Section 2 Checkpoint</h3>
        <p>Summary: LVM adds significant flexibility over static partitions, enabling dynamic resizing and storage pooling. The architectural flow moves from PV (Physical Volume) to VG (Volume Group) to LV (Logical Volume), and Proxmox installs to LVM by default to take advantage of these capabilities.</p>
        <p>Reflection: Can you shrink an LVM volume while it is online and actively in use? What is the difference between standard LVM and LVM-Thin provisioning?</p>
        <p>Resources:</p>
        <ul>
            <li>Red Hat LVM Administration</li>
        </ul>
        <div class="slide-number">Slide 11</div>
    </div>

    <div class="slide">
        <h2>3. ZFS: The Enterprise Standard (New Material)</h2>
        <div class="slide-number">Slide 12</div>
    </div>

    <div class="slide">
        <h3>3.1 Why ZFS?</h3>
        <ul>
            <li>Copy-on-Write (CoW) is one of ZFS's foundational design principles.</li>
            <li>When you edit a file, ZFS does not overwrite the old data in place.</li>
            <li>Instead, it writes the new data to a fresh block on the disk and then updates the pointer to reference the new location.</li>
            <li>The benefit of this approach is profound: if power fails during a write operation, the old data remains valid and intact.</li>
            <li>There is no corruption because the original block is never destroyed until the write is confirmed to be successful.</li>
        </ul>
        <p>The illustration below compares traditional write operations (which overwrite data in place) versus ZFS's Copy-on-Write approach:</p>
        <p>Figure 3: ZFS Copy-on-Write (CoW) - Traditional filesystems overwrite data in place; ZFS writes to new blocks and updates pointers</p>
        <ul>
            <li>Self-Healing is another critical feature of ZFS.</li>
            <li>The filesystem stores a cryptographic checksum (a digital fingerprint) for every block of data.</li>
            <li>If a cosmic ray flips a bit on your drive—an event known as bit rot—ZFS detects the mismatch between the data and its checksum.</li>
            <li>If redundancy exists (such as in a mirrored or RAID-Z configuration), ZFS automatically repairs the corrupted block by restoring it from a valid copy.</li>
        </ul>
        <p>The self-healing process is visualized below, showing how ZFS detects, validates, and repairs corrupted data blocks:</p>
        <p>Figure 4: ZFS Self-Healing - Checksums detect corrupted blocks, which are automatically repaired from redundant copies</p>
        <div class="slide-number">Slide 13</div>
    </div>

    <div class="slide">
        <h3>3.2 Basic ZFS Commands</h3>
        <p>Proxmox installs ZFS tools by default.</p>
        <div class="slide-number">Slide 14</div>
    </div>

    <div class="slide">
        <h3>3.3 The Power of Instant Snapshots</h3>
        <ul>
            <li>The Copy-on-Write architecture unlocks one of ZFS's most remarkable capabilities: instantaneous snapshots.</li>
            <li>Unlike traditional backup systems that must copy gigabytes or terabytes of data (a process that can take hours), a ZFS snapshot is merely a metadata operation—a lightweight bookmark that marks the current state of the filesystem.</li>
            <li>When you create a snapshot, ZFS doesn't duplicate any data blocks; it simply freezes a reference point in time.</li>
            <li>The snapshot consumes zero disk space initially because it shares all its data blocks with the current filesystem.</li>
            <li>Only when data begins to change does the snapshot start consuming space, as ZFS preserves the old blocks that the snapshot references while writing new data to fresh locations.</li>
        </ul>
        <div class="slide-number">Slide 15</div>
    </div>

    <div class="slide">
        <h3>Section 3 Checkpoint</h3>
        <ul>
            <li>Summary: ZFS is a next-generation filesystem with RAID, Copy-on-Write, and checksumming built directly into its architecture.</li>
            <li>Its self-healing capability detects and fixes silent data corruption (commonly known as bit rot), while snapshots are instantaneous and consume zero space initially due to the Copy-on-Write mechanism.</li>
        </ul>
        <p>Reflection: Why does ZFS need direct access to the disk (passthrough) rather than working through a traditional RAID controller? What is the "ARC" in ZFS terms, and how does it improve performance?</p>
        <p>Resources:</p>
        <ul>
            <li>OpenZFS Documentation</li>
        </ul>
        <div class="slide-number">Slide 16</div>
    </div>

    <div class="slide">
        <h2>4. Virtual Disk Formats</h2>
        <div class="slide-number">Slide 17</div>
    </div>

    <div class="slide">
        <h3>4.1 Raw (.raw)</h3>
        <ul>
            <li>The Raw disk format is effectively a bit-for-bit representation of a hard drive without any additional metadata or container structure.</li>
            <li>Because it lacks a translation layer, the file is read and written directly to the underlying block device, making it the most performant option available.</li>
            <li>However, this simplicity comes at a cost; creating a 100GB Raw disk immediately consumes 100GB of physical space (unless sparse provisioning is strictly enforced), and it does not support advanced features like internal snapshots.</li>
            <li>If you require snapshot capabilities with Raw disks, you must rely on the underlying storage system, such as LVM-Thin or ZFS, to handle them.</li>
        </ul>
        <div class="slide-number">Slide 18</div>
    </div>

    <div class="slide">
        <h3>4.2 QCOW2 (QEMU Copy On Write)</h3>
        <ul>
            <li>QCOW2 is a functional, feature-rich format designed specifically for the QEMU emulator.</li>
            <li>Unlike Raw, it acts as an intelligent container that creates a layer of abstraction between the VM and the physical disk.</li>
            <li>This allows for powerful features such as internal snapshots, transparent compression, and encryption directly within the file itself.</li>
            <li>While this abstraction layer introduces a minor performance overhead compared to Raw, the flexibility it offers—particularly the ability to grow the disk file dynamically as data is added—makes it the standard choice for file-based storage backends like NFS or local directories.</li>
        </ul>
        <div class="slide-number">Slide 19</div>
    </div>

    <div class="slide">
        <h3>4.3 Summary Comparison</h3>
        <p>The visual comparison below highlights the key differences between Raw and QCOW2 disk formats:</p>
        <p>Figure 5: Virtual Disk Formats - Raw disks offer maximum performance while QCOW2 provides flexibility with snapshots and thin provisioning</p>
        <table>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Raw (<code>.raw</code>)</th>
<th style="text-align: left;">QCOW2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Performance</strong></td>
<td style="text-align: left;">Highest (Near Native)</td>
<td style="text-align: left;">High (Slight Overhead)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Space Usage</strong></td>
<td style="text-align: left;">Fixed (Pre-allocated)</td>
<td style="text-align: left;">Dynamic (Grow on demand)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Snapshots</strong></td>
<td style="text-align: left;">Requires ZFS/LVM support</td>
<td style="text-align: left;">Built-in (Internal)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Portability</strong></td>
<td style="text-align: left;">Universal (Byte stream)</td>
<td style="text-align: left;">QEMU Specific</td>
</tr>
<tr>
<td style="text-align: left;">### Section 4 Checkpoint</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Summary</strong>:</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
        <ul>
            <li>Raw: Fast, pre-allocated, simple. Good for Ceph/LVM.</li>
            <li>QCOW2: Flexible, thin-provisioned, internal snapshots. Good for Directory/NFS.</li>
            <li>Trade-off is usually Performance vs Flexibility.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why can't you take an internal snapshot on a Raw disk?</li>
            <li>How does "sparse provisioning" differ from "thin provisioning"?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>QEMU Disk Images</li>
        </ul>
        <div class="slide-number">Slide 20</div>
    </div>

    <div class="slide">
        <h2>8. Additional Resources</h2>
        <div class="slide-number">Slide 21</div>
    </div>

    <div class="slide">
        <h2>9. Lab Exercises</h2>
        <div class="slide-number">Slide 22</div>
    </div>

    <div class="slide title-slide">
        <h2>Summary</h2>
        <p style="font-size: 1.5em; margin-top: 30px;">Review the key concepts covered in this week's material</p>
        <p style="font-size: 1.2em; margin-top: 20px; color: #ffd700;">Questions?</p>
        <div class="slide-number">Slide 23</div>
    </div>

</body>
</html>