<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Containers and Resource Management - Presentation Slides</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            page-break-after: always;
            border-bottom: 3px solid #0f3460;
        }
        
        .slide:nth-child(even) {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        }
        
        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .title-slide .week-number {
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .title-slide .course-code {
            font-size: 1.2em;
            color: #a8dadc;
            margin-top: 30px;
        }
        
        h2 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 30px;
            border-bottom: 3px solid #ffd700;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 25px;
        }
        
        ul {
            font-size: 1.4em;
            margin-left: 40px;
            margin-bottom: 20px;
        }
        
        ul li {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        p {
            font-size: 1.3em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .code-block {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', monospace;
            color: #a8dadc;
        }
        
        .quote {
            background: rgba(233, 69, 96, 0.1);
            border-left: 5px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.2em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        th {
            background: #0f3460;
            color: #ffd700;
            padding: 15px;
            text-align: left;
            border: 1px solid #16213e;
        }
        
        td {
            padding: 12px;
            border: 1px solid #16213e;
            background: rgba(255, 255, 255, 0.05);
        }
        
        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .key-points {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .vut-logo {
            position: fixed;
            bottom: 20px;
            right: 30px;
            height: 60px;
           width: auto;
            opacity: 0.8;
        }
        
        @media print {
            .slide {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>

    <div class="slide title-slide">
        <div class="week-number">Week 5</div>
        <h1>Containers and Resource Management</h1>
        <div class="course-code">OPS3 - Virtualization and Cloud Infrastructure</div>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>Welcome to Week 5!</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>What You'll Learn This Week</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>1. The Container Paradigm</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.1. The Foundation: Namespaces and Control Groups</h3>
        <ul>
            <li>Linux namespaces provide the fundamental isolation mechanism enabling containers.</li>
            <li>Each namespace type isolates a different aspect of the system.</li>
            <li>The PID (Process ID) Namespace isolates the process tree.</li>
            <li>On a normal Linux system, all processes share a single process ID space.</li>
            <li>With PID namespaces, each namespace has its own isolated process tree.</li>
        </ul>
        <ul>
            <li>The Network Namespace isolates network configuration completely.</li>
            <li>Each network namespace has its own network interfaces, IP addresses, routing tables, and firewall rules.</li>
            <li>This enables functionality that would otherwise conflict, such as multiple containers binding to port 80 on the same physical host.</li>
            <li>The Mount Namespace controls filesystem visibility, giving each container its own root filesystem (rootfs) that appears as the top of the directory tree.</li>
        </ul>
        <ul>
            <li>While namespaces provide isolation, they do not inherently limit resource consumption.</li>
            <li>Without additional mechanisms, a process in a container could consume all available CPU time or memory.</li>
            <li>Control Groups (cgroups) solve this problem by providing resource limiting, accounting, and prioritization.</li>
            <li>Understanding cgroups is essential because they form the foundation of resource management in all modern container platforms, from Docker to Kubernetes.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.2. Understanding Control Groups in Depth</h3>
        <ul>
            <li>Control Groups, commonly abbreviated as cgroups, are a Linux kernel feature that organizes processes into hierarchical groups and applies resource constraints to those groups.</li>
            <li>Think of cgroups as the traffic police of the Linux system: while namespaces create separate lanes of traffic (isolation), cgroups enforce speed limits and allocate road capacity (resource limits).</li>
        </ul>
        <ul>
            <li>When you create a container and specify that it can use "2 CPU cores" and "1GB of RAM," these limits are enforced through cgroups.</li>
            <li>The container runtime creates a cgroup for that container and configures the appropriate resource controllers.</li>
            <li>If the containerized application tries to exceed these limits, the kernel's cgroup subsystem intervenes to enforce the constraints.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.3. The cgroup Hierarchy</h3>
        <ul>
            <li>Cgroups are organized in a tree-like hierarchy, similar to how processes form a process tree.</li>
            <li>Each cgroup can have child cgroups, and resource limits applied to a parent cgroup affect all its children.</li>
            <li>This hierarchical structure enables sophisticated resource allocation strategies.</li>
            <li>For example, you might create a parent cgroup allocating 50% of CPU to "production workloads" and 50% to "development workloads," then subdivide those allocations further among individual containers.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.4. cgroup Controllers (Subsystems)</h3>
        <p>The power of cgroups comes from specialized controllers (also called subsystems), each responsible for managing a specific type of resource. The most critical controllers for container management include:</p>
        <ul>
            <li>This controller regulates access to CPU time.</li>
            <li>Administrators can use several mechanisms to control CPU allocation:
   - CPU Shares: A proportional weight system where containers with higher shares get more CPU time when there's contention.</li>
            <li>For example, if Container A has 1024 shares and Container B has 512 shares, Container A receives twice as much CPU time during periods of high demand.</li>
            <li>- CPU Quota: An absolute hard limit on CPU usage over a period.</li>
            <li>Setting a quota of 50000 microseconds per 100000 microsecond period limits the container to 50% of one CPU core.</li>
        </ul>
        <ul>
            <li>This controller manages memory allocation and prevents containers from consuming excessive RAM:
   - Memory Limit: Sets a hard cap on the amount of RAM a cgroup can use.</li>
            <li>When this limit is reached, the kernel may trigger the Out-Of-Memory (OOM) killer to terminate processes within the cgroup.</li>
            <li>- Memory Reservation: A soft limit that acts as a target.</li>
            <li>The kernel will attempt to reclaim memory from the cgroup when system-wide memory pressure occurs.</li>
            <li>- Swap Control: Determines whether the cgroup can use swap space and how much.</li>
        </ul>
        <p>This controller limits disk read/write operations:
   - I/O Weight: Similar to CPU shares, assigns proportional I/O bandwidth.
   - Throttling: Sets absolute limits on read/write operations per second (IOPS) or bytes per second.</p>
        <p>While technically separate from the primary cgroup implementation, network bandwidth can also be controlled through Traffic Control (tc) in conjunction with cgroups, allowing administrators to limit network throughput per container.</p>
        <p>Limits the number of processes (PIDs) that can be created within a cgroup, preventing fork bombs and runaway process creation.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.5. Practical cgroup Management</h3>
        <p>On modern Linux systems, cgroups are typically managed through the systemd init system, which uses cgroups extensively for service management. However, understanding direct cgroup manipulation is valuable for troubleshooting and advanced container configurations.</p>
        <p>The cgroup filesystem is typically mounted at /sys/fs/cgroup/. Each controller has its own subdirectory, and creating a new cgroup is as simple as creating a directory within that hierarchy.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.6. cgroups v1 vs v2</h3>
        <ul>
            <li>The Linux kernel has two major versions of the cgroup implementation.</li>
            <li>cgroups v1 (the original implementation) allowed each controller to operate independently with separate hierarchies.</li>
            <li>cgroups v2 (the modern unified hierarchy) consolidates all controllers into a single tree structure, simplifying management and improving consistency.</li>
        </ul>
        <p>Most modern Linux distributions (such as Ubuntu 22.04+ and Debian 11+) have transitioned to cgroups v2 by default. Docker and other container runtimes now support both versions, though v2 offers improved performance and a cleaner API.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.7. How Container Runtimes Use cgroups</h3>
        <p>When you run a container with resource limits, the container runtime (Docker, containerd, Podman, or LXC) performs these operations behind the scenes:</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.8. Example: Docker and cgroups</h3>
        <p>When you run the following Docker command:</p>
        <p>Docker creates a cgroup and configures it approximately like this:</p>
        <p>You can inspect these settings directly:</p>
        <p>Figure 2: Linux Namespaces and Cgroups - Namespaces provide isolation (PID, Network, Mount) while cgroups enforce resource limits (CPU, Memory)</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.9. Section 1 Checkpoint</h3>
        <p>Summary:
Namespaces: Provide isolation (Network, PID, Mount). The "Walls".
Control Groups (cgroups): Provide resource limiting (CPU, RAM). The "Police".
Containers share the Hot Kernel; VMs use their own Kernel.</p>
        <p>Reflection:
   If a container crashes the kernel, does the host crash? Why can't you run a Windows Container on a Linux Host (natively)?</p>
        <p>Resources:
Red Hat: What are Linux Namespaces?</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>2. The Container Technologies Landscape</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.1. LXC (Linux Containers)</h3>
        <ul>
            <li>LXC provides System Containers.</li>
            <li>The philosophy behind LXC is to offer a lightweight virtual machine experience without the overhead of hardware emulation.</li>
            <li>An LXC container boots a full init system (like systemd), runs multiple services (SSH, Cron, Syslog), and persists data like a traditional server.</li>
            <li>It is ideal for infrastructure consolidation where you require long-running servers but want the density and efficiency of containers.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.2. Docker</h3>
        <ul>
            <li>Docker popularized Application Containers.</li>
            <li>Unlike LXC, Docker allows you to package an application and its dependencies into a single runnable unit.</li>
            <li>A Docker container typically runs a single process (such as Nginx or Python) and is ephemeral in nature.</li>
            <li>Data is stored in external volumes, and the container itself can be destroyed and recreated easily.</li>
            <li>Docker is the standard for microservices and modern software delivery.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.3. Podman</h3>
        <ul>
            <li>Podman is a modern alternative to Docker, developed by Red Hat.</li>
            <li>It maintains compatibility with Docker's commands and image format (OCI) but differs significantly in architecture.</li>
            <li>Podman is daemonless; it does not require a background service running as root.</li>
            <li>Instead, it starts containers directly as child processes of the user.</li>
            <li>This architecture enhances security and natively supports "rootless" containers, allowing unprivileged users to run containers safely.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.4. Apptainer (formerly Singularity)</h3>
        <ul>
            <li>Apptainer is designed specifically for High Performance Computing (HPC) and research environments.</li>
            <li>In these environments, users run jobs on shared clusters where they do not have root access.</li>
            <li>Apptainer accommodates this by encapsulating the entire environment into a single file (.sif) and running it with the user's existing privileges.</li>
            <li>It prioritizes mobility of compute and integration with batch schedulers like Slurm.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.5. Comparison Table</h3>
        <p>Figure 3: Container Technologies Landscape - LXC for system containers, Docker for application containers, Podman for secure daemonless containers, Apptainer for HPC workloads</p>
        <table>
<thead>
<tr>
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">LXC</th>
<th style="text-align: left;">Docker</th>
<th style="text-align: left;">Podman</th>
<th style="text-align: left;">Apptainer</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Type</strong></td>
<td style="text-align: left;">System Container</td>
<td style="text-align: left;">Application Container</td>
<td style="text-align: left;">Application Container</td>
<td style="text-align: left;">Compute Container</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Philosophy</strong></td>
<td style="text-align: left;">"Lightweight VM"</td>
<td style="text-align: left;">"Single Service"</td>
<td style="text-align: left;">"Single Service"</td>
<td style="text-align: left;">"Portable Application"</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Management</strong></td>
<td style="text-align: left;"><code>lxc-*</code> commands</td>
<td style="text-align: left;"><code>docker</code> CLI</td>
<td style="text-align: left;"><code>podman</code> CLI</td>
<td style="text-align: left;"><code>apptainer</code> CLI</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Daemon</strong></td>
<td style="text-align: left;">None (Process based)</td>
<td style="text-align: left;"><strong>Yes (dockerd)</strong></td>
<td style="text-align: left;">No (Fork/Exec)</td>
<td style="text-align: left;">No</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Network</strong></td>
<td style="text-align: left;">System IP (Bridge)</td>
<td style="text-align: left;">Port Mapping</td>
<td style="text-align: left;">Port Mapping</td>
<td style="text-align: left;">Host Network (typ.)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Root Access</strong></td>
<td style="text-align: left;">Required for setup</td>
<td style="text-align: left;">Required (Daemon)</td>
<td style="text-align: left;"><strong>No (Rootless)</strong></td>
<td style="text-align: left;"><strong>No (Rootless)</strong></td>
</tr>
<tr>
<td style="text-align: left;"><strong>Image Format</strong></td>
<td style="text-align: left;">System Templates</td>
<td style="text-align: left;">OCI Layers</td>
<td style="text-align: left;">OCI Layers</td>
<td style="text-align: left;">Single File (.sif)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Primary Use</strong></td>
<td style="text-align: left;">Infrastructure / VPS</td>
<td style="text-align: left;">Microservices</td>
<td style="text-align: left;">Secure Microservices</td>
<td style="text-align: left;">Scientific / Research</td>
</tr>
</tbody>
</table>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.6. Section 2 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>LXC: System Containers (OS-like, persistent). Used for VPS/Infrastructure.</li>
            <li>Docker: Application Containers (Single process, ephemeral). Used for Dev/Microservices.</li>
            <li>Podman: Daemonless, secure alternative to Docker.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why is "Daemonless" considered a security feature?</li>
            <li>Which technology would you use to host a permanent MySQL server: LXC or Docker?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Open Container Initiative (OCI)</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>3. Working with System Containers (LXC CLI)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.1. Creating a Container</h3>
        <ul>
            <li>In the Docker ecosystem, users typically "pull" an image from a registry.</li>
            <li>In the LXC ecosystem, the process involves "creating" a container from a template.</li>
            <li>A template is a script or tarball that constructs the root filesystem for a specific Linux distribution.</li>
            <li>The lxc-create command handles this process, downloading the necessary files to a directory on the host (typically /var/lib/lxc).</li>
        </ul>
        <p>Figure 4: LXC Container Lifecycle - From template download through creation, start, attach, stop, to destroy</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.2. Listing and Monitoring</h3>
        <p>To view the status of containers, the lxc-ls command is used. The --fancy flag provides a formatted table showing the state (RUNNING or STOPPED), IP addresses (if running), and autostart configuration.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.3. Starting a Container</h3>
        <p>Booting an LXC container is significantly faster than booting a virtual machine because there is no kernel initialization. The lxc-start command simply initiates the init system within the isolated namespace environment.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.4. Accessing the Container</h3>
        <ul>
            <li>While it is possible to configure SSH for an LXC container, administrators often use lxc-attach to enter the container's namespace directly from the host.</li>
            <li>This works similarly to jumping into a chroot environment but respects the namespace boundaries.</li>
            <li>Once attached, you are the root user inside the container and can manage packages and services normally.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.5. Stopping and Destroying</h3>
        <p>Containers should be stopped gracefully to allow services to terminate correctly. The lxc-stop command sends the appropriate signals. When a container is no longer needed, lxc-destroy removes its configuration and deletes the root filesystem directory.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.6. Section 3 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Create: Builds a rootfs from a Template (lxc-create).</li>
            <li>Start: Boots the init system inside the namespace (lxc-start).</li>
            <li>Attach: Enters the namespace directly (lxc-attach).</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>How does lxc-attach differ from SSH?</li>
            <li>Where are the container filesystems actually stored on the host?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Linux Containers (LXC) Project</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>4. LXC in Proxmox VE (GUI Workflow)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.1. Step 1: Downloading Templates</h3>
        <ul>
            <li>Before a container can be created, a template must be available on the configured storage.</li>
            <li>In the Proxmox GUI, navigate to the storage view (such as local or local-lvm).</li>
            <li>The CT Templates section provides a built-in browser for downloading official templates for various distributions like Ubuntu, Debian, Alpine, and CentOS, as well as TurnKey Linux appliances which come pre-configured with software stacks.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.2. Step 2: Creating a Container</h3>
        <ul>
            <li>The creation wizard guides you through the configuration.</li>
            <li>Important settings include the Hostname, which sets the container's internal identity, and the Unprivileged option.</li>
            <li>Unprivileged containers are the default and recommended choice; they use user namespaces to map the container's root user to a non-privileged user on the host, significantly reducing the impact of a potential container escape.</li>
            <li>During Disk and CPU/Memory configuration, you set the resource limits that cgroups will enforce.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.3. Step 3: Managing Resources Dynamically</h3>
        <ul>
            <li>One of the key advantages of containers is the ability to adjust resources without rebooting.</li>
            <li>If a container is under memory pressure, you can navigate to the Resources tab in Proxmox and increase the Memory limit.</li>
            <li>The change is applied instantly to the running container's cgroup.</li>
            <li>This elasticity allows for highly efficient resource management compared to the static allocation often required for virtual machines.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.4. Section 4 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Proxmox uses typical LXC tech but wraps it in a GUI for ease of use.</li>
            <li>Templates: Must be downloaded to storage before creation.</li>
            <li>Unprivileged: Maps root inside container to non-root outside for security.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why is "Unprivileged" the default?</li>
            <li>How does dynamic resource resizing work with cgroups?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Proxmox VE: Linux Container (LXC)</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>5. Working with Application Containers (Docker CLI)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.1. Docker Architecture Components</h3>
        <ul>
            <li>The Docker platform comprises several interconnected components forming a complete ecosystem.</li>
            <li>Understanding this architecture clarifies how Docker operates.</li>
            <li>At the foundation, the Docker daemon (dockerd) runs as a persistent background service, managing Docker objects like images, containers, networks, and volumes.</li>
            <li>The Docker CLI (docker) provides the familiar command-line interface.</li>
            <li>When you run a command, it translates this into API calls to the daemon.</li>
        </ul>
        <p>Figure 5: Docker Architecture - Docker CLI communicates with Docker Daemon via REST API to manage images, containers, networks, and volumes</p>
        <ul>
            <li>Docker Images serve as the templates from which containers instantiate.</li>
            <li>An image is a read-only layered filesystem containing everything needed to run an application: base OS files, application code, runtime environments, and system libraries.</li>
            <li>Registries are repositories that store and serve these images.</li>
            <li>Docker Hub is the public registry hosting millions of images, while organizations may operate private registries for proprietary applications.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.2. Running a Container</h3>
        <p>Docker's most fundamental operation is docker run, which combines checking if the image exists locally, pulling it if missing, creating a container, and starting it.</p>
        <ul>
            <li>Breaking this command down: -d runs the container detached (in the background).</li>
            <li>--name web assigns a meaningful name, avoiding random identifiers.</li>
            <li>-p 8080:80 maps host port 8080 to container port 80, making the web server accessible at http://localhost:8080.</li>
            <li>The argument nginx specifies the image name; Docker pulls nginx:latest from Docker Hub by default.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.3. Managing Container Lifecycle</h3>
        <p>Managing running containers involves a set of essential commands for inspection and control.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.4. Inspecting and Debugging</h3>
        <p>The docker exec command is particularly useful for troubleshooting. It allows you to execute commands inside a running container. The -it flags allocate an interactive pseudo-TTY, giving you a shell prompt inside the container to inspect processes or check configurations.</p>
        <p>Resource usage can be monitored using docker stats, which provides real-time information on CPU, memory, and network usage for running containers.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.5. Building Custom Images with Dockerfiles</h3>
        <p>While pre-built images satisfy many needs, real applications require custom images. A Dockerfile is a text file containing instructions for building an image, where each instruction creates a new layer.</p>
        <p>Consider a simple Python web application. A Dockerfile might look like this:</p>
        <ul>
            <li>Each instruction has a specific purpose.</li>
            <li>FROM establishes the base image.</li>
            <li>WORKDIR sets the working directory.</li>
            <li>The sequence of copying requirements.txt before the rest of the code leverages layer caching: if your application code changes but your dependencies do not, Docker reuses the layer where dependencies are installed, significantly speeding up rebuilds.</li>
            <li>USER switches to a non-privileged user, a critical security best practice.</li>
        </ul>
        <p>Figure 6: Dockerfile Image Layers - Each instruction creates a new layer; cached layers speed up rebuilds when only code changes</p>
        <p>Building the image from this Dockerfile is done with the docker build command:</p>
        <p>This reads the Dockerfile in the current directory (.) and builds an image tagged as myapp:1.0.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.6. Section 5 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Images: Read-only layers containing the app.</li>
            <li>Containers: Runnable instances of images.</li>
            <li>Dockerfile: Recipe for building images.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why do we put the dependencies copy/install step before copying the app code in a Dockerfile?</li>
            <li>What happens to data inside a Docker container when you delete it?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Docker Curriculum</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>6. Working with Podman (Daemonless CLI)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.1. Running a Container (Rootless)</h3>
        <p>By default, Podman runs containers as the user who invoked the command, mapping the user's UID to root inside the container. This is a significant security advantage.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.2. Pods</h3>
        <p>Podman allows you to manage "Pods" locally. A Pod is a group of containers that share the same network namespace (localhost), a concept directly compatible with Kubernetes.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.3. Section 6 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Daemonless: Podman runs as the user process, avoiding the "Root Daemon" risk.</li>
            <li>Rootless: Allows unprivileged users to run containers safely.</li>
            <li>Pods: Groups of containers sharing a network namespace (localhost).</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>How can a rootless container bind to port 80 (privileged port)?</li>
            <li>Why is Podman considered "Kubernetes-friendly"?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Podman: Getting Started</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>7. Future Preview: Kubernetes and kubectl</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>7.1. The Core Concepts (The K8s Dictionary)</h3>
        <p>Understanding K8s requires learning a new vocabulary, distinct from Docker's:</p>
        <table>
<thead>
<tr>
<th style="text-align: left;">Docker Concept</th>
<th style="text-align: left;">Kubernetes Concept</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Container</strong></td>
<td style="text-align: left;"><strong>Pod</strong></td>
<td style="text-align: left;">A Pod is the smallest unit. It usually contains one container (like Nginx), but can contain helpers ("Sidecars"). Pods share a network namespace (localhost).</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Volme</strong></td>
<td style="text-align: left;"><strong>Volume / PVC</strong></td>
<td style="text-align: left;">Storage that persists beyond the Pod's lifecycle.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Network</strong></td>
<td style="text-align: left;"><strong>Service</strong></td>
<td style="text-align: left;">A stable IP address/DNS name that sits in front of dynamic Pods. If a Pod dies and is replaced, the Service IP stays the same.</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Compose File</strong></td>
<td style="text-align: left;"><strong>Manifest</strong></td>
<td style="text-align: left;">A YAML file describing the "Desired State" (e.g., "I want 3 copies of Nginx").</td>
</tr>
</tbody>
</table>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>7.2. The Control Loop (Desired State)</h3>
        <ul>
            <li>Kubernetes is Declarative.</li>
            <li>Unlike Docker, where you say "Run this container" (Imperative), in Kubernetes you say "I want 3 Nginx Pods" (Declarative).</li>
            <li>The Control Plane constantly checks:
1.</li>
            <li>What is the User's Desired State?</li>
            <li>(3 Pods)
2.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>7.3. The kubectl CLI</h3>
        <p>Start familiarizing yourself with these commands now. You will use them extensively in Week 11.</p>
        <p>1. Creating Resources (Imperative)</p>
        <div class="quote">Command Analysis:
*   run: Tells Kubernetes to create a single Pod.
*   --image=nginx: Uses the standard Nginx image from Docker Hub.
*   --restart=Never: Ensures this is treated as a simple Pod, not a managed service that automatically restarts.</div>
        <p>2. Inspecting Resources</p>
        <div class="quote">Command Analysis:
*   get: The universal command to list resources. You can use it for pods, nodes, services, etc.
*   describe: Shows the "Event Log" for a specific resource. If your Pod creation failed (e.g., "ImagePullBackOff"), this command tells you why.</div>
        <p>3. Scaling Applications</p>
        <div class="quote">Command Analysis:
*   create deployment: Instead of a single Pod, we create a Controller that manages Pods.
*   --replicas=3: We tell K8s we want 3 identical copies. K8s will start 3 Pods immediately.
*   scale: Changing this number updates the "Desired State." Kubernetes effectively "forks" 7 more copies to reach 10.</div>
        <p>4. Exposing to the World</p>
        <div class="quote">Command Analysis:
*   expose: Creates a Service that fronts the Deployment.
*   --type=NodePort: Opens a specific port (e.g., 32000) on every node in the cluster. This allows external traffic to reach your internal Pods.
*   --port=80: The internal port the container is listening on.</div>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>7.4. Self-Correction Checklist</h3>
        <ul>
            <li>Pod vs Container: A Pod wraps a container. K8s manages Pods, not containers directly.</li>
            <li>Service: Without a Service, you cannot reliably talk to a Pod because its IP changes every time it restarts.</li>
            <li>Magnum: We will use OpenStack Magnum to build the cluster, so we don't have to manage the Master Nodes ourselves.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>8. Summary</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>9. Additional Resources</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>9.1. Video Tutorials</h3>
        <ul>
            <li>LXC in Proxmox: YouTube (Compares to VMs, setup guide).</li>
            <li>Docker vs. Podman: YouTube (Explains differences, cloud use cases).</li>
            <li>Docker Basics: YouTube (Beginner guide to Docker containers).</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>9.2. Documentation & Further Reading</h3>
        <ul>
            <li>Proxmox LXC Documentation</li>
            <li>Docker Documentation</li>
            <li>Podman Documentation</li>
            <li>OpenStack Zun</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>10. Lab Exercises</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide title-slide">
        <h2>Summary</h2>
        <p style="font-size: 1.5em; margin-top: 30px;">Review the key concepts covered in this week's material</p>
        <p style="font-size: 1.2em; margin-top: 20px; color: #ffd700;">Questions?</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

</body>
</html>