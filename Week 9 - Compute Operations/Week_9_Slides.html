<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compute Operations (Nova) - Presentation Slides</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            page-break-after: always;
            border-bottom: 3px solid #0f3460;
        }
        
        .slide:nth-child(even) {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        }
        
        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .title-slide .week-number {
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .title-slide .course-code {
            font-size: 1.2em;
            color: #a8dadc;
            margin-top: 30px;
        }
        
        h2 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 30px;
            border-bottom: 3px solid #ffd700;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 25px;
        }
        
        ul {
            font-size: 1.4em;
            margin-left: 40px;
            margin-bottom: 20px;
        }
        
        ul li {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        p {
            font-size: 1.3em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .code-block {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', monospace;
            color: #a8dadc;
        }
        
        .quote {
            background: rgba(233, 69, 96, 0.1);
            border-left: 5px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.2em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        th {
            background: #0f3460;
            color: #ffd700;
            padding: 15px;
            text-align: left;
            border: 1px solid #16213e;
        }
        
        td {
            padding: 12px;
            border: 1px solid #16213e;
            background: rgba(255, 255, 255, 0.05);
        }
        
        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .key-points {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .vut-logo {
            position: fixed;
            bottom: 20px;
            right: 30px;
            height: 60px;
           width: auto;
            opacity: 0.8;
        }
        
        @media print {
            .slide {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>

    <div class="slide title-slide">
        <div class="week-number">Week 9</div>
        <h1>Compute Operations (Nova)</h1>
        <div class="course-code">OPS3 - Virtualization and Cloud Infrastructure</div>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>1. Introduction to OpenStack Compute (Nova)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 1 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Nova is the compute controller, equivalent to Microsoft.Compute.</li>
            <li>Cellular Architecture: Partitions the cloud for scalability and resilience.</li>
            <li>Hypervisor Agnostic: Nova manages the hypervisor (KVM) but is not the hypervisor itself.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why does Nova need a "Cellular Architecture" for large-scale clouds?</li>
            <li>What is the difference between Nova and KVM?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>2. Nova Component Anatomy</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.1 The Global Components (Control Plane)</h3>
        <ul>
            <li>The entry point for all requests is nova-api.</li>
            <li>This service accepts REST requests from users and other services.</li>
            <li>It first validates the user's authentication token via Keystone before passing the request into the system.</li>
            <li>Crucially, nova-api is stateless, meaning scaling it is as simple as running multiple copies behind a Load Balancer.</li>
        </ul>
        <ul>
            <li>The decision-making heart of the cloud is nova-scheduler.</li>
            <li>Its sole responsibility is to decide where a new virtual machine should be placed.</li>
            <li>It does not create the VM or touch the hypervisor; it simply selects the most appropriate host from the pool of available resources and passes the message along.</li>
            <li>It achieves this through a sophisticated Filter-and-Weight algorithm.</li>
        </ul>
        <ul>
            <li>Finally, the nova-conductor acts as a security guard for the database.</li>
            <li>In a cloud environment, compute nodes are considered "untrusted" because they run user workloads that could potentially be malicious.</li>
            <li>If a hacker were to escape a VM and gain control of the compute node, we must ensure they cannot corrupt the entire cloud database.</li>
            <li>Therefore, compute nodes are not allowed to write to the database directly.</li>
            <li>Instead, they send a message to the Conductor requesting an update, and the Conductor performs the write operation only after validating the request.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.2 The Node Components (Data Plane)</h3>
        <ul>
            <li>On every hypervisor server, the nova-compute service acts as the worker.</li>
            <li>It continually listens for instructions from the message queue (RabbitMQ).</li>
            <li>When it receives a command, such as "Run Instance," it does not execute it blindly; it follows a rigorous process to ensure the VM is built correctly on the physical hardware.</li>
        </ul>
        <ul>
            <li>The Driver Layer (Libvirt)
nova-compute is designed to be hypervisor-agnostic.</li>
            <li>It does not speak directly to the kernel; instead, it uses a driver.</li>
            <li>In our Linux environment, it uses the Libvirt driver.</li>
            <li>When you ask for a VM, nova-compute translates your request into a Libvirt XML file—a precise recipe describing the VM's CPU, RAM, and Devices—and passes it to the Libvirt daemon, which ultimately spawns the QEMU/KVM process.</li>
        </ul>
        <ul>
            <li>The Resource Tracker
Beyond creating VMs, nova-compute is responsible for auditing the physical server.</li>
            <li>It runs a periodic task (typically every 60 seconds) called the Resource Tracker.</li>
            <li>This task scans the available RAM, CPU cores, and Disk space on the host and compares it against the reserved resources.</li>
            <li>It then reports this "Inventory" back to the central database.</li>
            <li>This ensures that the Scheduler always possesses an accurate, up-to-date map of the cloud's capacity, preventing it from sending a VM to a host that is already full.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 2 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Control Plane: nova-api (Entry), nova-scheduler (Decision), nova-conductor (DB Guard).</li>
            <li>Data Plane: nova-compute (Hypervisor Worker).</li>
            <li>Security: Compute nodes cannot talk directly to the DB; they go through Conductor.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why is nova-api considered "stateless"?</li>
            <li>Why do we need a "Conductor" to protect the database?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>3. The Scheduling Algorithm (The Decision Process)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.1 Pass 1: Filtering (Qualifying)</h3>
        <p>The first pass is designed to remove any hosts that are incapable of running the instance. It works like a sieve.</p>
        <ul>
            <li>RamFilter: Checks if the host has enough free RAM to satisfy the requested flavor.</li>
            <li>ComputeFilter: Ensures the host service is actually alive and reporting.</li>
            <li>AvailabilityZoneFilter: Ensures the VM lands in the requested physical location.</li>
            <li>ImagePropertiesFilter: Checks for specific hardware requirements like GPUs or Secure Boot support.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.2 Pass 2: Weighting (Ranking)</h3>
        <p>Once the invalid hosts are removed, the second pass ranks the remaining candidates to find the "best" fit. The default RamWeigher checks the free RAM on each host.</p>
        <ul>
            <li>Stacking Strategy: Fills up one server completely before moving to the next. This saves power but creates hotspots.</li>
            <li>Spreading Strategy (Default): Places the VM on the emptiest possible server to maximize performance and minimize the "noisy neighbor" effect.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 3 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Filtering: Removes invalid hosts (e.g., Not enough RAM).</li>
            <li>Weighting: Ranks valid hosts (e.g., Emptiest first).</li>
            <li>Goal: Select the single best host (Candidate) for the VM.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>What is the difference between "Stacking" and "Spreading" strategies?</li>
            <li>Which filter ensures a VM lands on a host with a GPU?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>4. The Instance Lifecycle (State Machine)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 4 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>BUILD: Scheduling and Networking in progress.</li>
            <li>ACTIVE: VM is running on the Hypervisor.</li>
            <li>ERROR: Something went wrong (Check logs).</li>
            <li>SHELVED: VM offloaded to disk.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>What happens during the "Spawning" phase?</li>
            <li>How does SHELVED differ from a simple Shutdown?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5. Operations Cookbook (CLI): Launching Nebula Inc.</h3>
        <ul>
            <li>In Week 8, we established the digital foundation for Nebula Inc.</li>
            <li>We created the Project (nebula_prod), hired the User (nebula_admin), and wired the Office Network (nebula_net).</li>
            <li>However, the data center currently sits empty.</li>
            <li>To bring the company online, we must now define the virtual hardware standards (Flavors), issue security credentials (Keys & Groups), and finally press the "Power On" button for their first Web Server.</li>
        </ul>
        <p>Below are the commands to execute this activation.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.1 Defining Flavors (Capacity)</h3>
        <p>In a physical data center, you buy specific server models. In OpenStack, we abstract this capacity into what the platform calls Flavors (Instance Types in AWS/Azure). A Flavor is a virtual hardware template that defines the resource limits (vCPU, RAM, Disk).</p>
        <p>The Provider vs. Consumer Role:</p>
        <ul>
            <li>Public Cloud (AWS/Azure): You are a Consumer. You cannot create new sizes; you can only Select from the menu Amazon provides (t2.micro, m5.large).</li>
            <li>Private Cloud (OpenStack): You are the Provider. It is your job to Create the menu that your users will select from.</li>
        </ul>
        <p>1. Listing Existing Flavors (The Menu)
Before creating new ones, check what is available.</p>
        <p>2. Creating a Custom Flavor (The Chef)
For "Nebula Inc.", we need a custom "Micro" size for cheap testing. We will name it m1.nebula_micro.</p>
        <p>Naming Convention Decoding:</p>
        <ul>
            <li>m1: Generation/Class. (e.g., "m" for General Purpose, "1" for 1st Generation). This mirrors AWS naming (e.g., t2.micro = Burstable, 2nd Gen).</li>
            <li>nebula: Family. Identifies this as a custom flavor for our organization.</li>
            <li>micro: Size. Indicates relative capacity (Micro < Small < Medium).</li>
        </ul>
        <ul>
            <li>Result: We have added a new item to the menu. Users can now select m1.nebula_micro when launching instances.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.2 Securing Access (Keys & Groups)</h3>
        <p>Security in the cloud is a two-layered approach. First, we must secure Identity (proving who you are) using Keypairs. Second, we must secure the Network (controlling traffic flow) using Security Groups. You cannot access a VM unless both of these layers are correctly configured.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.2.1 Keypairs (Login Access)</h3>
        <ul>
            <li>Unlike traditional servers where you set a root password, Cloud images (AWS, Azure, OpenStack) verify identity using Asymmetric Cryptography.</li>
            <li>This mechanism leverages a "Lock and Key" relationship to secure access.</li>
            <li>The Public Key acts as the "Lock"; you upload this to the cloud, and Nova injects it into the VM's .ssh/authorized_keys file during boot.</li>
            <li>It is safe to share and visible to anyone.</li>
            <li>The Private Key acts as the unique "Key"; you keep this securely on your laptop and must never share it.</li>
        </ul>
        <p>Generating a Keypair</p>
        <ul>
            <li>Explanation: This command generates the pair. It stores the Public Key in the Nova Database and writes the Private Key to nebula_key.pem on your disk. The chmod is critical; SSH will refuse to use a key if the file permissions are too open.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.2.2 Security Groups (The Virtual Firewall)</h3>
        <p>In traditional networking, firewalls are physical appliances sitting at the edge of the network. In Cloud Computing, we use Security Groups. A Security Group is a virtual firewall that is applied directly to the network interface (vNIC) of an instance, regardless of where it runs in the data center.</p>
        <p>Figure 3: Security Group Architecture - How the Open vSwitch Agent filters packets on the Hypervisor before they reach the VM</p>
        <p>Concept (General Cloud)
Security groups operate on specific principles:</p>
        <ul>
            <li>Stateful: If you allow a request out (e.g., download update), the return traffic is automatically allowed in.</li>
            <li>Allow-List: The default policy is "Implicit Deny". All traffic is blocked until you explicitly allow it.</li>
            <li>Dynamic: Rules are applied immediately to all running instances without rebooting.</li>
        </ul>
        <ul>
            <li>OpenStack Implementation
When you create a rule, Neutron communicates with the Open vSwitch (OVS) agent on the Compute Node.</li>
            <li>It translates your high-level rule (e.g., "Allow Port 80") into low-level OVS Flow Tables or iptables chains on the physical hypervisor.</li>
            <li>This ensures malicious traffic is dropped on the physical wire before it ever reaches your VM, providing a robust first line of defense.</li>
        </ul>
        <p>CLI: Configuring the Firewall
We must explicitly open ports for SSH and Web access.</p>
        <ul>
            <li>Result: The OVS Agent on the compute node intercepts traffic to nebula_web_01 and filters it against these rules.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.3 Launching Instances</h3>
        <p>The server create command brings together the Flavor, Image, Network, Key, and Security Group to instantiate a VM.</p>
        <p>Boot Command</p>
        <ul>
            <li>Explanation:
--flavor: Defines the size.
--image: Defines the software (OS).
--network: Defines the wiring.
Result: Triggers the entire scheduling and build process seen in Section 4.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.4 Day 2 Operations (Debugging & Access)</h3>
        <p>Floating IPs (Public Access)
To access the VM from the internet, map a public IP to it.</p>
        <p>Console Logs (Troubleshooting)
If a VM fails to become reachable (e.g., no network), check the boot logs.</p>
        <ul>
            <li>Explanation: Retrieves the kernel ring buffer (dmesg) and cloud-init output directly from the hypervisor. Use this to find kernel panics or DHCP failures.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 5 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Flavor: Virtual hardware template (CPU/RAM). Provider defines, Consumer selects.</li>
            <li>Security Group: Stateful virtual firewall. "Implicit Deny" by default.</li>
            <li>Keypairs: SSH Keys for identity. Private Key never leaves your laptop.</li>
            <li>Floating IP: Assigns a public address to reach the VM from outside.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why must we use chmod 600 on the private key?</li>
            <li>How does an "Allow-List" firewall differ from a traditional "Block-List"?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>6. Industry Comparison: The "Polyglot" Cloud Engineer</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.1 Concept Mapping</h3>
        <table>
<thead>
<tr>
<th style="text-align: left;">Concept</th>
<th style="text-align: left;">OpenStack Term</th>
<th style="text-align: left;">AWS Term</th>
<th style="text-align: left;">Azure Term</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>Compute Provider</strong></td>
<td style="text-align: left;">Nova</td>
<td style="text-align: left;">EC2 (Service)</td>
<td style="text-align: left;">Azure Compute (<code>Microsoft.Compute</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Size Template</strong></td>
<td style="text-align: left;">Flavor (e.g., <code>m1.small</code>)</td>
<td style="text-align: left;">Instance Type (e.g., <code>t2.micro</code>)</td>
<td style="text-align: left;">VM Size (e.g., <code>Standard_B1s</code>)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Firewall</strong></td>
<td style="text-align: left;">Security Group</td>
<td style="text-align: left;">Security Group</td>
<td style="text-align: left;">Network Security Group (NSG)</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Login Key</strong></td>
<td style="text-align: left;">Keypair</td>
<td style="text-align: left;">Key Pair</td>
<td style="text-align: left;">SSH Key</td>
</tr>
<tr>
<td style="text-align: left;"><strong>Default User</strong></td>
<td style="text-align: left;"><code>cirros</code>, <code>ubuntu</code></td>
<td style="text-align: left;"><code>ec2-user</code>, <code>ubuntu</code></td>
<td style="text-align: left;"><code>azureuser</code></td>
</tr>
<tr>
<td style="text-align: left;">### 6.2 CLI Rosetta Stone</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">Below is the exact same "Launch Instance" workflow translated into the three major languages of the cloud.</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
        <p>1. Create a "Flavor" (Size)</p>
        <ul>
            <li>OpenStack: openstack flavor list (Selects m1.small)</li>
            <li>AWS: aws ec2 describe-instance-types (Selects t2.micro)</li>
            <li>Azure: az vm list-sizes (Selects Standard_B1s)</li>
        </ul>
        <p>2. Create a Firewall</p>
        <ul>
            <li>OpenStack: openstack security group create web-sg</li>
            <li>AWS: aws ec2 create-security-group --group-name web-sg</li>
            <li>Azure: az network nsg create --name web-nsg</li>
        </ul>
        <p>3. Launch the Instance (The "Hello World" of Cloud)
Notice how similar the flags are across all three platforms.</p>
        <p>OpenStack (Nova)</p>
        <p>AWS (EC2)</p>
        <p>Azure (Compute)</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 6 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Concepts are universal; only terms change (Flavor -> Instance Type).</li>
            <li>Nova = AWS EC2 = Azure Compute.</li>
            <li>Security Group is the standard term across OpenStack and AWS.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why is it valuable to learn the underlying concept rather than just the tool command?</li>
            <li>How does "Infrastructure as Code" rely on these standardized CLI commands?</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>7. Summary and Next Steps</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Preparing for Week 10</h3>
        <p>Next week, we tackle Storage and Persistence. A web server is useless if it loses all its data when it reboots. We will explore Cinder (Block Storage) to give our instances persistent hard drives.</p>
        <p>Checklist:</p>
        <ul>
            <li>Ensure you can launch an instance from the CLI without looking at the manual.</li>
            <li>Verify you can SSH into your instance using your keypair.</li>
            <li>Review the "Instance Lifecycle" states (Build -> Active).</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>8. Additional Resources</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>9. Lab Exercises</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide title-slide">
        <h2>Summary</h2>
        <p style="font-size: 1.5em; margin-top: 30px;">Review the key concepts covered in this week's material</p>
        <p style="font-size: 1.2em; margin-top: 20px; color: #ffd700;">Questions?</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

</body>
</html>