<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Networking and Linux Networking Fundamentals - Presentation Slides</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            line-height: 1.6;
        }
        
        .slide {
            min-height: 100vh;
            padding: 60px 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            page-break-after: always;
            border-bottom: 3px solid #0f3460;
        }
        
        .slide:nth-child(even) {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
        }
        
        .title-slide {
            justify-content: center;
            align-items: center;
            text-align: center;
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
        }
        
        .title-slide h1 {
            font-size: 3.5em;
            margin-bottom: 20px;
            color: #e94560;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .title-slide .week-number {
            font-size: 1.5em;
            color: #ffd700;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .title-slide .course-code {
            font-size: 1.2em;
            color: #a8dadc;
            margin-top: 30px;
        }
        
        h2 {
            font-size: 2.5em;
            color: #e94560;
            margin-bottom: 30px;
            border-bottom: 3px solid #ffd700;
            padding-bottom: 15px;
        }
        
        h3 {
            font-size: 2em;
            color: #ffd700;
            margin-bottom: 25px;
        }
        
        ul {
            font-size: 1.4em;
            margin-left: 40px;
            margin-bottom: 20px;
        }
        
        ul li {
            margin-bottom: 15px;
            line-height: 1.8;
        }
        
        p {
            font-size: 1.3em;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .code-block {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
        }
        
        pre {
            background: #0f0f0f;
            border-left: 4px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 1.1em;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', monospace;
            color: #a8dadc;
        }
        
        .quote {
            background: rgba(233, 69, 96, 0.1);
            border-left: 5px solid #e94560;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            font-size: 1.2em;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 1.2em;
        }
        
        th {
            background: #0f3460;
            color: #ffd700;
            padding: 15px;
            text-align: left;
            border: 1px solid #16213e;
        }
        
        td {
            padding: 12px;
            border: 1px solid #16213e;
            background: rgba(255, 255, 255, 0.05);
        }
        
        tr:hover {
            background: rgba(233, 69, 96, 0.1);
        }
        
        img {
            max-width: 100%;
            height: auto;
            margin: 20px 0;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .key-points {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .vut-logo {
            position: fixed;
            bottom: 20px;
            right: 30px;
            height: 60px;
           width: auto;
            opacity: 0.8;
        }
        
        @media print {
            .slide {
                page-break-after: always;
            }
        }
    </style>
</head>
<body>

    <div class="slide title-slide">
        <div class="week-number">Week 3</div>
        <h1>Virtual Networking and Linux Networking Fundamentals</h1>
        <div class="course-code">OPS3 - Virtualization and Cloud Infrastructure</div>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>Welcome to Week 3!</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>What You'll Learn This Week</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>1. Runtime vs. Persistent Networking (ip vs nmcli)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.1 The Kernel Layer: ip (Runtime)</h3>
        <p>The ip command is part of the iproute2 suite. It communicates directly with the Linux Kernel via Netlink sockets. When you run an ip command, you are modifying the direct, in-memory state of the network stack.</p>
        <ul>
            <li>Speed: Changes happen instantly (microseconds).</li>
            <li>Scope: Changes affect the running system only.</li>
            <li>Risk: Changes are lost on reboot. If you restart the server, the kernel reloads, and your manual ip changes disappear.</li>
        </ul>
        <p>Key Commands:</p>
        <ul>
            <li>Link Status: ip link show (Displays MTU, MAC addresses, and UP/DOWN state).</li>
            <li>IP Addresses: ip addr show (Displays IPv4/IPv6 addresses attached to links).</li>
            <li>Routing Table: ip route get 8.8.8.8 (Simulates a packet to 8.8.8.8 and tells you which interface and gateway would be used).</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>1.2 The Configuration Layer: nmcli (Persistent)</h3>
        <p>To make settings permanent, we need a daemon that reads config files and applies them at boot. In modern Linux (including RHEL/CentOS and many Debian setups), this is NetworkManager. The command-line tool for this is nmcli.</p>
        <ul>
            <li>Profiles: NetworkManager saves settings as "Connection Profiles" (saved in /etc/NetworkManager/system-connections/).</li>
            <li>Logic: It handles complex logic, like "connect to Wi-Fi X when available, otherwise fall back to Ethernet Y."</li>
            <li>Persistence: Changes made here are written to disk and survive reboots.</li>
        </ul>
        <p>Hands-On Example:
Use nmcli to set a static IP, ensuring the server always boots with the same address.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 1 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>ip commands are runtime only (lost on reboot).</li>
            <li>nmcli commands are persistent (saved to disk).</li>
            <li>Correct networking requires understanding both layers.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why did Linux move away from ifconfig?</li>
            <li>If you set an IP with ip addr add and then reboot, what happens?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Red Hat: ip Command Cheat Sheet</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>2. Network Namespaces (The "Containers" of Networking)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.1 The "Tenant Problem"</h3>
        <p>Imagine you are hosting Amazon Web Services. Customer A wants a private network using the IP range 192.168.1.0/24. Customer B also wants to use 192.168.1.0/24. On a normal OS, you cannot have the same IP address twice. It would cause an IP conflict.</p>
        <ul>
            <li>To solve this, we use Namespaces.</li>
            <li>A Network Namespace is like a parallel universe for networking.</li>
            <li>It partitions the kernel's network structures.</li>
            <li>Inside a namespace, you have a completely independent set of interfaces, routes, and firewall rules.</li>
            <li>Customer A lives in Namespace A, and Customer B lives in Namespace B.</li>
        </ul>
        <p>Figure 2.1: Visualizing Isolation of Network Resources within a Single Linux Kernel.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>2.2 Hands-On Example</h3>
        <p>We will create a "sandbox" namespace to demonstrate this total isolation.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 2 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Namespaces isolate network stacks (interfaces, routes, firewalls).</li>
            <li>They solve the "Multi-Tenant" problem (overlapping IPs).</li>
            <li>They are the foundation of all Container technology.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Can a process in Namespace A see the network traffic of Namespace B?</li>
            <li>How does this isolation improve security in a cloud environment?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Introduction to Linux Namespaces</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>3. Connecting the Dots: Veth Pairs and Bridges</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.1 The Virtual Cable (veth)</h3>
        <ul>
            <li>You cannot plug a physical Ethernet cable into a software namespace.</li>
            <li>Instead, Linux provides the Virtual Ethernet (veth) device.</li>
            <li>A veth pair is always created as two connected interfaces—a "pipe." Packets sent into Interface A instantly arrive at Interface B, and vice versa.</li>
            <li>This allows us to tunnel traffic from the Global Host namespace into the isolated "sandbox" namespace.</li>
        </ul>
        <p>Hands-On Example:
Connecting the Sandbox to the Host.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>3.2 The Virtual Switch (bridge)</h3>
        <ul>
            <li>Connecting two points with a veth is easy.</li>
            <li>But what if you have 50 Containers?</li>
            <li>You cannot create a mesh of cables between every single one.</li>
            <li>You need a device to connect them all to a central point.</li>
            <li>A Linux Bridge is a software implementation of a standard Ethernet Switch.</li>
        </ul>
        <ul>
            <li>MAC Learning: The bridge listens to incoming frames. If it sees a packet from MAC AA:BB:CC coming from Port 1, it records this in a table.</li>
            <li>Forwarding: If it later receives a packet destined for AA:BB:CC, it looks up the table and sends it only to Port 1. This reduces traffic congestion compared to a "Hub" which broadcasts everything.</li>
        </ul>
        <p>How devices plug in:</p>
        <ul>
            <li>Containers: Use veth pairs (as discussed in 3.1).</li>
            <li>Virtual Machines: Use TAP Interfaces. A tap device simulates an Ethernet device at Layer 2. QEMU/KVM creates a tap interface (e.g., tap100i0) for the VM, and the other end connects to the Bridge. This allows the VM to send raw Ethernet frames onto the switch.</li>
        </ul>
        <p>Example: Manually creating a TAP interface (What Proxmox does behind the scenes)</p>
        <p>Hands-On Example: Connecting Two Namespaces (Red & Blue)
We will act as a "Virtual Switch" administrator. We want to connect two isolated namespaces so they can talk to each other.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 3 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>veth pairs act as virtual cables connecting namespaces.</li>
            <li>Linux Bridges act as virtual switches, forwarding frames based on MAC addresses.</li>
            <li>We can build complex topologies entirely in software.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>If you forget to "plug" the veth into the bridge (master br0), what happens?</li>
            <li>Why do we need two ends to a veth pair?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Linux Bridge Command Help</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>4. Container Networking in Practice (Docker, Podman, LXC)</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.1 Docker (The Standard Bridge)</h3>
        <p>When you install Docker, it creates a Linux Bridge named docker0.</p>
        <ul>
            <li>The Bridge: docker0 (Usually 172.17.0.1/16).</li>
            <li>The Veth: Every time you run docker run, Docker creates a veth pair. One end sits on the host (plugged into docker0), the other sits inside the container.</li>
            <li>The Namespace: The container is just a process running inside a network namespace.</li>
        </ul>
        <p>CLI Comparison:</p>
        <table>
<thead>
<tr>
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Manual Linux Command</th>
<th style="text-align: left;">Docker Command</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Create Net</td>
<td style="text-align: left;"><code>ip link add br0 type bridge</code></td>
<td style="text-align: left;"><code>docker network create mynet</code></td>
</tr>
<tr>
<td style="text-align: left;">Create NS</td>
<td style="text-align: left;"><code>ip netns add container1</code></td>
<td style="text-align: left;"><code>docker run --name container1 ...</code></td>
</tr>
<tr>
<td style="text-align: left;">Connect</td>
<td style="text-align: left;"><code>ip link set veth master br0</code></td>
<td style="text-align: left;">Auto-connected to <code>docker0</code> or custom net</td>
</tr>
</tbody>
</table>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.2 Podman (Rootless Networking)</h3>
        <p>Podman often manages containers without root privileges. Standard bridges require root. How does it work?</p>
        <ul>
            <li>slirp4netns: Podman uses a User-Space networking stack. It "slurps" traffic from the host interface and pipes it into the container namespace without touching the kernel's actual bridge settings.</li>
            <li>Performance: Slightly slower than Docker's bridge, but much more secure.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>4.3 LXC (System Containers)</h3>
        <p>LXC is closer to Proxmox's approach. It typically uses lxcbr0.</p>
        <ul>
            <li>Unlike Docker, LXC networking is defined in a config file. By default, it connects to lxcbr0 and requests an IP via DHCP, just like a physical computer would.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 4 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Docker automates the creation of Bridges (docker0) and Veth pairs.</li>
            <li>Podman uses slirp4netns for rootless, secure networking.</li>
            <li>LXC behaves more like traditional VMs on the network.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>Why is "Rootless" networking considered more secure?</li>
            <li>How does docker network create simplify what we did in Section 3?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Docker Networking Overview</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>5. Advanced Linux Operations</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.1 Link Aggregation (Bonding/LACP)</h3>
        <p>Hardware fails. Cables get cut, SFP modules burn out, and switch ports die. If your Hypervisor is connected via a single cable, you have a Single Point of Failure (SPOF).</p>
        <p>Bonding allows you to combine multiple physical interfaces (e.g., eno1 and eno2) into a single virtual interface (bond0).</p>
        <ul>
            <li>Mode 1 (Active-Backup): Only one cable is used. If it fails, the traffic flips to the second cable. Simple, but wastes 50% bandwidth.</li>
            <li>Mode 4 (802.3ad LACP): The Gold Standard. The server and switch communicate to balance traffic across both cables simultaneously. You get double the speed and redundancy.</li>
        </ul>
        <p>Configuration:</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.2 IP Forwarding & Routing</h3>
        <p>A Linux server usually behaves like an End Host—it consumes packets sent to it and ignores the rest. However, in virtualization (specifically NAT Mode), the Linux host must act as a Router. It needs to accept packets from VMs and forward them to the Internet.</p>
        <p>To do this, we must toggle a specialized kernel parameter: ip_forward. We also need to manipulate the Routing Table to tell the kernel where networks live.</p>
        <p>Commands:</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.3 The Linux Firewall (iptables)</h3>
        <ul>
            <li>Security in the cloud isn't just about an external firewall appliance.</li>
            <li>Every Linux kernel has a built-in firewall called Netfilter.</li>
            <li>We manipulate it using iptables.</li>
            <li>It processes packets in "Chains":
1.</li>
            <li>INPUT: Filters traffic destined for the localhost.</li>
        </ul>
        <p>Hands-On Example: securing a host.</p>
        <p>Modern Frontends: firewalld vs iptables
While iptables (and its successor nftables) is the low-level tool, managing thousands of rules manually is hard. Modern distros use "Frontend Controllers":</p>
        <ul>
            <li>RHEL/CentOS/Fedora: Use firewalld. It organizes rules into "Zones" (Public, Home, Work).</li>
        </ul>
        <ul>
            <li>Debian/Ubuntu: Often use ufw (Uncomplicated Firewall).</li>
        </ul>
        <p>These tools write the underlying iptables/nftables rules for you.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.4 Network Reconnaissance (ss & nmap)</h3>
        <p>Before you can analyze traffic, you often need to know what ports are open or who is listening.</p>
        <p>Socket Statistics (ss)
ss is the modern replacement for the deprecated netstat. It allows you to see which processes on your server are listening for connections.</p>
        <p>Network Mapper (nmap)
nmap is the industry standard for network discovery. Unlike ss (which looks locally), nmap allows you to scan remote servers to see what they are exposing.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>5.5 Traffic Analysis (tcpdump)</h3>
        <p>When networking breaks, it often fails silently. A firewall drops a packet without an error message. A route sends traffic into a black hole. To fix this, we need Packet Capture.</p>
        <p>tcpdump is the CLI version of Wireshark. It puts the network card into "Promiscuous Mode," allowing it to see every packet on the wire, not just those addressed to it.</p>
        <p>Commands:</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 5 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Bonding aggregates links for redundancy (Active/Backup) or speed (LACP).</li>
            <li>Routing allows a Linux host to act as a Gateway.</li>
            <li>IPTables controls traffic flow (Input, Output, Forward).</li>
            <li>SS/Nmap allow you to discover open ports and listening services.</li>
            <li>Tcpdump allows us to see the actual packets on the wire.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>If you have a Bond with 2 cables and one is cut, does the server go offline?</li>
            <li>Why do we need ip_forward=1 for NAT?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Tcpdump 101</li>
        </ul>
        <p>Now that we have dismantled the Linux kernel concepts, we can look at how Proxmox Virtual Environment (PVE) uses them to manage VM networking. Proxmox does not invent its own networking stack; it "orchestrates" standard Linux tools (Bridges, OVS, IPTables) via a web interface.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>6. Open vSwitch (OVS): The Cloud Switch</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.1 Architecture: Control Plane vs. Data Plane</h3>
        <ul>
            <li>Unlike a physical dumb switch, OVS is split into two parts:
1.</li>
            <li>Userspace (Control Plane): ovs-vswitchd and ovsdb-server handle the database and logic.</li>
            <li>This is where you configure "Flows" and "Ports".</li>
            <li>2.</li>
            <li>Kernel Module (Data Plane): This handles the actual packet switching at wire speed.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.2 Installing OVS</h3>
        <p>Unlike the standard bridge, OVS is not always installed by default.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.3 The Power of Flows</h3>
        <p>Standard bridges forward based on MAC addresses. OVS forwards based on Flow Rules. A flow rule matches a packet's header fields and performs an action.</p>
        <p>Example Scenario:
You want to block a specific "Bad Neighbor" VM (IP 10.0.0.66) from sending traffic, but allow everything else.</p>
        <ul>
            <li>Linux Bridge: Cannot do this natively (needs complex iptables).</li>
            <li>OVS: One simple command.</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>6.4 SDN Controller Integration</h3>
        <p>OVS is designed to be controlled remotely by an SDN Controller (like OpenDaylight or ONOS). This allows a central brain to program the switches across the entire datacenter.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 6 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>OVS is a programmable, carrier-grade virtual switch.</li>
            <li>It separates the Control Plane (Logic) from the Data Plane (Forwarding).</li>
            <li>It uses "Flows" instead of just MAC tables, allowing for complex logic (Drop IP X, Redirect Port Y).</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>How does OVS differ from a standard Linux Bridge?</li>
            <li>What is the role of an SDN Controller?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Open vSwitch Crash Course</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>7. Proxmox Networking</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>7.1 Networking Modes</h3>
        <p>When configuring a VM's hardware, you choose how it connects to the bridge. We primarily see three patterns.</p>
        <p>This is the standard configuration for 90% of deployments. The VM becomes a full peer on the physical network.</p>
        <p>Packet Flow:
[VM eth0] -> [Host tap100i0] -> [Linux Bridge vmbr0] -> [Physical NIC eno1] -> [Physical Switch]</p>
        <p>Detailed Configuration:
In /etc/network/interfaces, a Bridge looks like this:</p>
        <p>Implication:</p>
        <ul>
            <li>DHCP: The VM sends a broadcast DISCOVER packet. It traverses the bridge, hits the physical wire, and reaches your office router. The router assigns an IP directly to the VM.</li>
            <li>Visibility: Every device on your LAN can ping the VM.</li>
        </ul>
        <p>Sometimes you cannot get extra public IPs (e.g., in a data center giving you only 1 IP). You need to create a private network inside the host and share the single public IP.</p>
        <p>Packet Flow:
[VM eth0] -> [Host tap100i0] -> [Private Bridge vmbr1] -> [Host Routing/NAT] -> [Physical NIC eno1] -> Internet</p>
        <p>Detailed Configuration:
This mode requires Masquerading (Source NAT) in iptables.</p>
        <p>VLANs allow multiple logical networks to share one physical cable. To do this, we insert a 4-byte "Tag" into the Ethernet Frame Header.</p>
        <p>Processing Flow:</p>
        <p>You can create VLAN interfaces on standard Linux without a bridge using the ip command. This creates a virtual interface that automatically tags/untags packets.</p>
        <p>Egress (Host -> Switch): The packet leaves eno1 with the tag attached. The physical switch reads "20" and puts it in the correct broadcast domain.</p>
        <p>VLAN Aware Bridge:
Modern Proxmox uses "VLAN Aware" bridges. Instead of creating vmbr0.10, vmbr0.20, etc., you toggle bridge-vlan-aware yes. The bridge then acts like a "Trunk Port", capable of carrying all VLANs simultaneously.</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h3>Section 7 Checkpoint</h3>
        <p>Summary:</p>
        <ul>
            <li>Proxmox uses standard Linux Bridges and IPTables underneath the GUI.</li>
            <li>Bridged Mode: VM is on the LAN. Simplest.</li>
            <li>NAT Mode: VM is hidden behind the Host. Requires Masquerading.</li>
            <li>VLANs: Isolate traffic on the same physical wire using Tags.</li>
        </ul>
        <p>Reflection:</p>
        <ul>
            <li>If you are in a Data Center with only 1 Public IP, which mode MUST you use?</li>
            <li>How does a switch know which VLAN a packet belongs to?</li>
        </ul>
        <p>Resources:</p>
        <ul>
            <li>Proxmox Network Model</li>
        </ul>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>8. Additional Resources</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide">
        <h2>9. Lab Exercises</h2>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

    <div class="slide title-slide">
        <h2>Summary</h2>
        <p style="font-size: 1.5em; margin-top: 30px;">Review the key concepts covered in this week's material</p>
        <p style="font-size: 1.2em; margin-top: 20px; color: #ffd700;">Questions?</p>
        <img src="../ops3_logo.png" alt="VUT Logo" class="vut-logo">
    </div>

</body>
</html>